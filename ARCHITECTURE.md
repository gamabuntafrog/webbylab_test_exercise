# Архітектура програми

## Огляд

Цей документ описує високорівневу архітектуру backend-додатку для управління фільмами (Movies API). Додаток побудований на базі Express.js з TypeScript та використовує SQLite як базу даних.

## Архітектурний патерн

Програма використовує **Layered Architecture (Шарова архітектура)** з чітким розділенням відповідальностей між шарами:

```
┌─────────────────────────────────────────┐
│           HTTP Request                  │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│         Middleware Layer                │
│  (CORS, Logging, Auth, Error Handling) │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│          Routes Layer                   │
│      (API Endpoints Definition)         │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│        Controllers Layer                │
│    (Request Validation & Response)      │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│         Services Layer                  │
│       (Business Logic)                  │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│       Repositories Layer                │
│      (Data Access Layer)                │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│         Database Layer                  │
│    (SQLite via Sequelize ORM)           │
└─────────────────────────────────────────┘
```

## Основні компоненти

### 1. Routes (Маршрутизація)

**Призначення**: Визначає API endpoints та прив'язує їх до контролерів.

**Розташування**: `src/routes/`

**Основні файли**:
- `movieRoutes.ts` - маршрути для роботи з фільмами
- `userRoutes.ts` - маршрути для роботи з користувачами
- `sessionRouter.ts` - маршрути для аутентифікації

### 2. Controllers (Контролери)

**Призначення**: Обробляє HTTP запити, валідує вхідні дані та формує відповіді.

**Розташування**: `src/controllers/`

**Основні файли**:
- `movieController.ts` - обробка запитів щодо фільмів
- `authController.ts` - обробка аутентифікації
- `userController.ts` - обробка запитів щодо користувачів

**Відповідальність**:
- Валідація вхідних даних через Zod схеми
- Виклик методів сервісів для виконання бізнес-логіки
- Формування HTTP відповідей
- Обробка помилок через next(error)


### 3. Services (Сервіси / Бізнес-логіка)

**Призначення**: Містить всю бізнес-логіку додатку, координує роботу між репозиторіями.

**Розташування**: `src/services/`

**Основні файли**:
- `movieService.ts` - логіка роботи з фільмами та акторами
- `authService.ts` - логіка аутентифікації та авторизації
- `userService.ts` - логіка роботи з користувачами

**Відповідальність**:
- Реалізація бізнес-правил та валідацій
- Координація між кількома репозиторіями
- Управління транзакціями бази даних
- Трансформація даних між форматами (DTO ↔ Model)

### 4. Repositories (Репозиторії)

**Призначення**: Абстракція доступу до даних, інкапсулює роботу з базою даних.

**Розташування**: `src/repositories/`

**Основні файли**:
- `BaseRepository.ts` - базовий клас з CRUD операціями
- `MovieRepository.ts` - репозиторій для фільмів
- `ActorRepository.ts` - репозиторій для акторів
- `UserRepository.ts` - репозиторій для користувачів
- `MovieActorRepository.ts` - репозиторій для зв'язків фільм-актор

**Відповідальність**:
- CRUD операції з моделями
- Складні запити до бази даних
- Робота з асоціаціями Sequelize
- Підтримка транзакцій

**Особливості**:
- Наслідування від `BaseRepository` для спільної функціональності
- Type-safe доступ до інших Sequlize моделей для вкладених запитів
- Автодоповнення для атрибутів моделей у TypeScript

### 5. Models (Моделі даних)

**Призначення**: Визначає структуру даних та зв'язки між сутностями.

**Розташування**: `src/db/models/`

**Основні моделі**:
- `User.ts` - користувачі системи
- `Movie.ts` - фільми
- `Actor.ts` - актори
- `MovieActor.ts` - зв'язок many-to-many між фільмами та акторами

**Особливості**:
- Визначення через Sequelize
- Типізація через TypeScript
- Реєстрація зв'язків через `AssociationRegistry`

### 6. Middleware

**Призначення**: Обробка запитів на рівні додатку перед досягненням маршрутів.

**Розташування**: `src/middleware/`

**Глобальні middleware** (`src/middleware/global/`):
- `corsMiddleware.ts` - налаштування CORS
- `requestLogger.ts` - логування HTTP запитів
- `errorHandler.ts` - централізована обробка помилок

**Спеціалізовані middleware**:
- `authMiddleware.ts` - аутентифікація через JWT токени

**Порядок виконання**:
```
CORS → Request Logger → JSON Parser → Routes → Error Handler
```

### 7. Database (База даних)

**Технологія**: SQLite з Sequelize ORM

**Розташування**: `src/db/`

**Компоненти**:
- `database.ts` - підключення до БД та конфігурація Sequelize
- `associations.ts` - реєстр зв'язків між моделями
- `migrations/` - система міграцій на базі Umzug (нативна робота з typescript файлами)

## Допоміжні компоненти

### Validators (Валідатори)

**Призначення**: Визначення схем валідації вхідних даних через Zod.

**Розташування**: `src/validators/`

**Особливості**:
- Типобезпечна валідація
- Автоматична генерація TypeScript типів
- Перевірка параметрів запиту, тіла та query string

### Helpers

**Призначення**: Утилітарні функції для різних задач.

**Розташування**: `src/helpers/`

**Основні файли**:
- `authHelper.ts` - робота з JWT токенами
- `batchHelper.ts` - батч-обробка даних
- `movieImportParser.ts` - парсинг файлів з фільмами
- `requestHelper.ts` - допоміжні функції для роботи з запитами

### Mappers (Маппери)

**Призначення**: Трансформація даних між різними форматами.

**Розташування**: `src/mappers/`

**Особливості**:
- Конвертація HTTP запитів у DTO
- Валідація через Zod схеми
- Типобезпечні перетворення

### Errors (Обробка помилок)

**Призначення**: Стандартизована обробка помилок додатку.

**Розташування**: `src/errors/`

**Особливості**:
- Кастомні класи помилок (`AppError`, `NotFoundError`, `UnauthorizedError`)
- Коди помилок через `ERROR_CODES`
- Централізована обробка в `errorHandler` middleware

### Configuration (Конфігурація)

**Призначення**: Управління конфігурацією додатку через змінні оточення.

**Розташування**: `src/config/`

**Особливості**:
- Singleton паттерн для доступу до конфігурації
- Валідація обов'язкових змінних
- Значення за замовчуванням для розробки
- Типобезпечний доступ до конфігурації

## Потік обробки запиту

### Типовий запит (наприклад, створення фільму)

```
1. HTTP Request (POST /api/v1/movies)
   ↓
2. CORS Middleware - перевірка дозволених origins
   ↓
3. Request Logger - логування запиту
   ↓
4. JSON Parser - парсинг тіла запиту
   ↓
5. Route Handler - знаходження відповідного маршруту
   ↓
6. Controller.createMovie()
   ├─ Mapper - валідація через Zod схему
   ├─ Service.createMovie()
   │  ├─ Repository.find() - перевірка існування акторів
   │  ├─ Transaction - початок транзакції
   │  ├─ Repository.create() - створення фільму
   │  ├─ Repository.create() - створення акторів (якщо потрібно)
   │  ├─ Repository.create() - створення зв'язків MovieActor
   │  └─ Transaction - коміт транзакції
   └─ Response - формування JSON відповіді
   ↓
7. Error Handler (якщо виникла помилка)
   ↓
8. HTTP Response
```

### Запит з аутентифікацією

```
1. HTTP Request (GET /api/v1/users/me)
   ↓
2. CORS Middleware
   ↓
3. Request Logger
   ↓
4. Auth Middleware
   ├─ Перевірка Authorization header
   ├─ Верифікація JWT токена
   └─ Додавання user до request
   ↓
5. Route Handler
   ↓
6. Controller.getCurrentUser()
   └─ Service.getCurrentUser()
      └─ Repository.findById()
   ↓
7. Response
```

## Ключові архітектурні рішення

### 1. Dependency Injection

Всі залежності передаються через конструктори, що спрощує тестування та підтримку:

```typescript
// Repository → Service → Controller
const repository = new MovieRepository(MovieModel, modelsRegistry);
const service = new MovieService(repository, actorRepository, movieActorRepository);
const controller = new MovieController(service);
```

### 2. Transaction Management

Складні операції виконуються в транзакціях для забезпечення атомарності:

```typescript
await withTransaction(async (transaction) => {
  // Множинні операції БД
});
```

### 3. Batch Processing

Великі обсяги даних обробляються батчами для оптимізації:

```typescript
await processInBatches(items, batchSize, async (batch) => {
  // Обробка батчу
});
```

### 4. Type Safety

Повна типізація через TypeScript забезпечує:
- Автодоповнення в IDE
- Перевірку типів на етапі компіляції
- Безпеку рефакторингу

## Структура бази даних

### Основні сутності

**Users** - користувачі системи
- id (UUID)
- email (унікальний)
- password (хешований)

**Movies** - фільми
- id (INTEGER)
- title (STRING)
- year (INTEGER)
- format (ENUM: VHS, DVD, Blu-Ray)
- createdAt, updatedAt

**Actors** - актори
- id (INTEGER)
- name (STRING, унікальний)
- createdAt, updatedAt

**MovieActors** - зв'язок many-to-many
- id (INTEGER)
- movie_id (FK → Movies)
- actor_id (FK → Actors)

### Асоціації

- Movie ↔ Actor: Many-to-Many через MovieActor
- Movie → MovieActor: One-to-Many
- Actor → MovieActor: One-to-Many

## Безпека

### Аутентифікація

- JWT токени (access + refresh)
- Хешування паролів через bcryptjs
- Middleware для перевірки токенів

### Валідація

- Валідація всіх вхідних даних через Zod
- Захист від SQL ін'єкцій через Sequelize ORM
- Обмеження розміру файлів через Multer

### CORS

- Налаштування дозволених origins через змінні оточення
- Підтримка множинних origins

## Масштабованість та продуктивність

### Оптимізації

- Батч-обробка для великих операцій
- Транзакції для атомарних операцій
- Індекси в базі даних для швидкого пошуку
- Пагінація для великих списків

### Моніторинг

- Структуроване логування через Pino
- Health check endpoint (`/health`)
- Логування всіх HTTP запитів

## Розгортання

### Docker

- Multi-stage build для оптимізації розміру образу
- Використання змінних оточення для конфігурації
- Підтримка міграцій при старті контейнера

### Environment Variables

Вся конфігурація через змінні оточення:
- `APP_PORT` - порт сервера
- `DATABASE_PATH` - шлях до БД
- `JWT_SECRET` - секрет для JWT
- `FRONTEND_ORIGIN` - дозволені CORS origins
- та інші...

## Висновок

Архітектура додатку побудована на принципах:
- **Розділення відповідальностей** - кожен шар має чітко визначену роль
- **Модульність** - компоненти незалежні та можуть бути легко замінені
- **Типобезпека** - повна підтримка TypeScript
- **Масштабованість** - архітектура дозволяє легко додавати нові функції
- **Підтримуваність** - чітка структура спрощує розробку та підтримку


